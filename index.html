<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 5px;
        }
        h2 {
            color: #555;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        canvas {
            display: block;
            margin: 10px auto;
            border: 1px solid #ddd;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 15px 0;
        }
        .control-section {
            flex: 1;
            min-width: 250px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 6px;
            border: 1px solid #eee;
        }
        .control-group {
            margin-bottom: 12px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #444;
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .checkbox-group label {
            margin-bottom: 0;
            margin-left: 8px;
        }
        .data-display {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 6px;
            border: 1px solid #eee;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
            display: none;
        }
        .hover-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
        }
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        .color-sample {
            width: 20px;
            height: 20px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #ccc;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 3px;
        }
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Enhanced Perlin Noise Visualization</h1>
        
        <div class="tabs">
            <div class="tab active" data-tab="visualization">Visualization</div>
            <div class="tab" data-tab="data">Raw Data</div>
        </div>
        
        <div id="visualization-panel">
            <div class="controls">
                <div class="control-section">
                    <h2>Noise Parameters</h2>
                    <div class="control-group">
                        <label for="scale">Scale: <span id="scale-value">20</span></label>
                        <input type="range" id="scale" min="5" max="100" value="20">
                    </div>
                    
                    <div class="control-group">
                        <label for="octaves">Octaves: <span id="octaves-value">1</span></label>
                        <input type="range" id="octaves" min="1" max="8" value="1">
                    </div>
                    
                    <div class="control-group">
                        <label for="persistence">Persistence: <span id="persistence-value">0.5</span></label>
                        <input type="range" id="persistence" min="1" max="100" value="50">
                    </div>
                    
                    <div class="control-group">
                        <label for="zOffset">Z Offset (Time): <span id="zOffset-value">0</span></label>
                        <input type="range" id="zOffset" min="0" max="100" value="0">
                    </div>
                    
                    <button id="regenerate">Generate New Seed</button>
                </div>
                
                <div class="control-section">
                    <h2>Visualization Options</h2>
                    <div class="control-group">
                        <label for="colorMode">Color Mode:</label>
                        <select id="colorMode">
                            <option value="grayscale">Grayscale</option>
                            <option value="terrain">Terrain</option>
                            <option value="fire">Fire</option>
                            <option value="ocean">Ocean</option>
                            <option value="rainbow">Rainbow</option>
                            <option value="raw">Raw Values</option>
                        </select>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid" checked>
                        <label for="showGrid">Show Grid</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showContours">
                        <label for="showContours">Show Contour Lines</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="show3D">
                        <label for="show3D">Show 3D Effect</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showLabels">
                        <label for="showLabels">Show Value Labels</label>
                    </div>
                    
                    <div class="control-group">
                        <label for="resolution">Resolution: <span id="resolution-value">1</span></label>
                        <input type="range" id="resolution" min="1" max="10" value="1">
                    </div>
                </div>
            </div>
            
            <div id="legend" class="color-legend"></div>
            
            <canvas id="noiseCanvas" width="800" height="400"></canvas>
            
            <div class="hover-info" id="hoverInfo">Hover over the canvas to see values</div>
        </div>
        
        <div id="data-panel" style="display: none;">
            <div class="controls">
                <div class="control-group">
                    <label for="dataType">Data Type:</label>
                    <select id="dataType">
                        <option value="raw">Raw Noise Values</option>
                        <option value="octave">Individual Octave Values</option>
                        <option value="gradient">Gradient Vectors</option>
                        <option value="stats">Statistical Analysis</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="dataSampleSize">Sample Size:</label>
                    <select id="dataSampleSize">
                        <option value="small">Small (10x10)</option>
                        <option value="medium">Medium (20x20)</option>
                        <option value="large">Large (Full)</option>
                    </select>
                </div>
                
                <button id="exportData">Export Data (CSV)</button>
            </div>
            
            <div class="data-display" id="dataDisplay"></div>
        </div>
    </div>

    <script>
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                this.generatePermutationTable();
            }
            
            generatePermutationTable() {
                const p = Array.from({length: 256}, (_, i) => i);
                
                for (let i = p.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }
                
                this.permutation = [...p, ...p];
            }
            
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            
            lerp(a, b, t) {
                return a + t * (b - a);
            }
            
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            noise(x, y = 0, z = 0) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);

                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                
                const A = this.permutation[X] + Y;
                const AA = this.permutation[A] + Z;
                const AB = this.permutation[A + 1] + Z;
                const B = this.permutation[X + 1] + Y;
                const BA = this.permutation[B] + Z;
                const BB = this.permutation[B + 1] + Z;
                
                const gradAA = this.grad(this.permutation[AA], x, y, z);
                const gradBA = this.grad(this.permutation[BA], x - 1, y, z);
                const gradAB = this.grad(this.permutation[AB], x, y - 1, z);
                const gradBB = this.grad(this.permutation[BB], x - 1, y - 1, z);
                const gradAA1 = this.grad(this.permutation[AA + 1], x, y, z - 1);
                const gradBA1 = this.grad(this.permutation[BA + 1], x - 1, y, z - 1);
                const gradAB1 = this.grad(this.permutation[AB + 1], x, y - 1, z - 1);
                const gradBB1 = this.grad(this.permutation[BB + 1], x - 1, y - 1, z - 1);
                
                this.lastGradients = {
                    gradAA, gradBA, gradAB, gradBB,
                    gradAA1, gradBA1, gradAB1, gradBB1
                };
                
                const result = this.lerp(
                    this.lerp(
                        this.lerp(gradAA, gradBA, u),
                        this.lerp(gradAB, gradBB, u),
                        v
                    ),
                    this.lerp(
                        this.lerp(gradAA1, gradBA1, u),
                        this.lerp(gradAB1, gradBB1, u),
                        v
                    ),
                    w
                );
                
                return (result + 1) / 2;
            }
            
            octaveNoise(x, y, z, octaves, persistence) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;
                
                this.octaveValues = [];
                
                for (let i = 0; i < octaves; i++) {
                    const value = this.noise(x * frequency, y * frequency, z * frequency) * amplitude;
                    this.octaveValues.push({
                        octave: i,
                        frequency,
                        amplitude,
                        value
                    });
                    
                    total += value;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }
                
                return total / maxValue;
            }
            
            getRawData(width, height, scale, octaves, persistence, zOffset, resolution) {
                const data = [];
                
                for (let y = 0; y < height; y += resolution) {
                    const row = [];
                    for (let x = 0; x < width; x += resolution) {
                        const value = this.octaveNoise(x / scale, y / scale, zOffset, octaves, persistence);
                        row.push(value);
                    }
                    data.push(row);
                }
                
                return data;
            }
            
            getOctaveData(width, height, scale, octaves, persistence, zOffset, resolution) {
                const data = [];
                
                for (let i = 0; i < octaves; i++) {
                    const octaveData = [];
                    let frequency = Math.pow(2, i);
                    let amplitude = Math.pow(persistence, i);
                    
                    for (let y = 0; y < height; y += resolution) {
                        const row = [];
                        for (let x = 0; x < width; x += resolution) {
                            const value = this.noise(x / scale * frequency, y / scale * frequency, zOffset * frequency) * amplitude;
                            row.push(value);
                        }
                        octaveData.push(row);
                    }
                    
                    data.push({
                        octave: i,
                        frequency,
                        amplitude,
                        data: octaveData
                    });
                }
                
                return data;
            }
            
            getStatsData(rawData) {
                const flatValues = rawData.flat();
                const min = Math.min(...flatValues);
                const max = Math.max(...flatValues);
                
                const sortedValues = [...flatValues].sort((a, b) => a - b);
                const length = sortedValues.length;
                
                const sum = sortedValues.reduce((acc, val) => acc + val, 0);
                const mean = sum / length;
                
                const median = length % 2 === 0 
                    ? (sortedValues[length/2 - 1] + sortedValues[length/2]) / 2
                    : sortedValues[Math.floor(length/2)];
                
                const squareDiffs = sortedValues.map(value => {
                    const diff = value - mean;
                    return diff * diff;
                });
                const avgSquareDiff = squareDiffs.reduce((acc, val) => acc + val, 0) / length;
                const stdDev = Math.sqrt(avgSquareDiff);
                
                const percentile = (p) => {
                    const index = Math.floor(length * p / 100);
                    return sortedValues[index];
                };
                
                return {
                    min,
                    max,
                    mean,
                    median,
                    stdDev,
                    p10: percentile(10),
                    p25: percentile(25),
                    p75: percentile(75),
                    p90: percentile(90),
                    histogram: this.calculateHistogram(flatValues, min, max)
                };
            }
            
            calculateHistogram(values, min, max, bins = 10) {
                const histogram = Array(bins).fill(0);
                const binSize = (max - min) / bins;
                
                values.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - min) / binSize), bins - 1);
                    histogram[binIndex]++;
                });
                
                return histogram.map((count, i) => ({
                    binStart: min + i * binSize,
                    binEnd: min + (i + 1) * binSize,
                    count,
                    frequency: count / values.length
                }));
            }
        }

        class NoiseVisualizer {
            constructor() {
                this.perlin = new PerlinNoise();
                this.canvas = document.getElementById('noiseCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.hoverInfo = document.getElementById('hoverInfo');
                this.dataDisplay = document.getElementById('dataDisplay');
                
                this.controls = {
                    scale: document.getElementById('scale'),
                    octaves: document.getElementById('octaves'),
                    persistence: document.getElementById('persistence'),
                    zOffset: document.getElementById('zOffset'),
                    colorMode: document.getElementById('colorMode'),
                    showGrid: document.getElementById('showGrid'),
                    showContours: document.getElementById('showContours'),
                    show3D: document.getElementById('show3D'),
                    showLabels: document.getElementById('showLabels'),
                    resolution: document.getElementById('resolution'),
                    regenerate: document.getElementById('regenerate'),
                    dataType: document.getElementById('dataType'),
                    dataSampleSize: document.getElementById('dataSampleSize'),
                    exportData: document.getElementById('exportData')
                };
                
                this.displayValues = {
                    scale: document.getElementById('scale-value'),
                    octaves: document.getElementById('octaves-value'),
                    persistence: document.getElementById('persistence-value'),
                    zOffset: document.getElementById('zOffset-value'),
                    resolution: document.getElementById('resolution-value')
                };
                
                this.tabs = {
                    buttons: document.querySelectorAll('.tab'),
                    panels: {
                        visualization: document.getElementById('visualization-panel'),
                        data: document.getElementById('data-panel')
                    }
                };
                
                this.noiseData = null;
                this.octaveData = null;
                this.statsData = null;
                this.hoveredCell = null;
                
                this.setupEventListeners();
                this.updateDisplayValues();
                this.renderNoise();
                this.updateLegend();
            }
            
            setupEventListeners() {
                this.tabs.buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabName = button.getAttribute('data-tab');
                        this.switchTab(tabName);
                    });
                });
                
                this.controls.scale.addEventListener('input', () => {
                    this.updateDisplayValues();
                    this.renderNoise();
                });
                
                this.controls.octaves.addEventListener('input', () => {
                    this.updateDisplayValues();
                    this.renderNoise();
                });
                
                this.controls.persistence.addEventListener('input', () => {
                    this.updateDisplayValues();
                    this.renderNoise();
                });
                
                this.controls.zOffset.addEventListener('input', () => {
                    this.updateDisplayValues();
                    this.renderNoise();
                });
                
                this.controls.resolution.addEventListener('input', () => {
                    this.updateDisplayValues();
                    this.renderNoise();
                });
                
                this.controls.colorMode.addEventListener('change', () => {
                    this.renderNoise();
                    this.updateLegend();
                });
                
                this.controls.showGrid.addEventListener('change', () => this.renderNoise());
                this.controls.showContours.addEventListener('change', () => this.renderNoise());
                this.controls.show3D.addEventListener('change', () => this.renderNoise());
                this.controls.showLabels.addEventListener('change', () => this.renderNoise());
                
                this.controls.regenerate.addEventListener('click', () => {
                    this.perlin.generatePermutationTable();
                    this.renderNoise();
                });
                
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasHover(e));
                this.canvas.addEventListener('mouseout', () => {
                    this.hoveredCell = null;
                    this.hoverInfo.textContent = 'Hover over the canvas to see values';
                });
                
                this.controls.dataType.addEventListener('change', () => this.updateDataDisplay());
                this.controls.dataSampleSize.addEventListener('change', () => this.updateDataDisplay());
                
                this.controls.exportData.addEventListener('click', () => this.exportData());
            }
            
            updateDisplayValues() {
                this.displayValues.scale.textContent = this.controls.scale.value;
                this.displayValues.octaves.textContent = this.controls.octaves.value;
                this.displayValues.persistence.textContent = (this.controls.persistence.value / 100).toFixed(2);
                this.displayValues.zOffset.textContent = this.controls.zOffset.value;
                this.displayValues.resolution.textContent = this.controls.resolution.value;
            }
            
            switchTab(tabName) {
                this.tabs.buttons.forEach(btn => {
                    if (btn.getAttribute('data-tab') === tabName) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                
                Object.keys(this.tabs.panels).forEach(panel => {
                    if (panel === tabName) {
                        this.tabs.panels[panel].style.display = 'block';
                    } else {
                        this.tabs.panels[panel].style.display = 'none';
                    }
                });
                
                if (tabName === 'data') {
                    this.updateDataDisplay();
                }
            }
            
            getColorForValue(value, mode) {
                switch (mode) {
                    case 'grayscale':
                        const intensity = Math.floor(value * 255);
                        return `rgb(${intensity},${intensity},${intensity})`;
                    
                    case 'terrain':
                        if (value < 0.3) return `rgb(0,0,${Math.floor(150 + value * 350)})`; 
                        if (value < 0.4) return `rgb(${Math.floor(240 + value * 60)},${Math.floor(240 + value * 60)},90)`; 
                        if (value < 0.7) return `rgb(0,${Math.floor(100 + value * 155)},0)`; 
                        return `rgb(${Math.floor(220 * (value - 0.7) / 0.3 + 80)},${Math.floor(220 * (value - 0.7) / 0.3 + 80)},${Math.floor(220 * (value - 0.7) / 0.3 + 80)})`; 
                    case 'fire':
                        return `rgb(${Math.floor(255)},${Math.floor(value * 200)},0)`;
                    
                    case 'ocean':
                        return `rgb(0,${Math.floor(50 + value * 100)},${Math.floor(150 + value * 105)})`;
                    
                    case 'rainbow':
                        const h = value * 360; 
                        const s = 80; 
                        const l = 50;
                        
                        const c = (1 - Math.abs(2 * l / 100 - 1)) * s / 100;
                        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                        const m = l / 100 - c / 2;
                        
                        let r, g, b;
                        if (h < 60) { r = c; g = x; b = 0; }
                        else if (h < 120) { r = x; g = c; b = 0; }
                        else if (h < 180) { r = 0; g = c; b = x; }
                        else if (h < 240) { r = 0; g = x; b = c; }
                        else if (h < 300) { r = x; g = 0; b = c; }
                        else { r = c; g = 0; b = x; }
                        
                        return `rgb(${Math.floor((r + m) * 255)},${Math.floor((g + m) * 255)},${Math.floor((b + m) * 255)})`;
                    
                    case 'raw':
                        return `rgb(${Math.floor(value * 255)},${Math.floor(value * 255)},${Math.floor(value * 255)})`;
                    
                    default:
                        return `rgb(${Math.floor(value * 255)},${Math.floor(value * 255)},${Math.floor(value * 255)})`;
                }
            }
            
            getLegendItems(mode) {
                switch (mode) {
                    case 'terrain':
                        return [
                            { color: 'rgb(0,0,200)', label: 'Deep Water (< 0.3)' },
                            { color: 'rgb(240,240,90)', label: 'Sand (0.3-0.4)' },
                            { color: 'rgb(0,150,0)', label: 'Grass (0.4-0.7)' },
                            { color: 'rgb(150,150,150)', label: 'Mountains (> 0.7)' }
                        ];
                    
                    case 'fire':
                        return [
                            { color: 'rgb(255,0,0)', label: 'Hot (Low Value)' },
                            { color: 'rgb(255,100,0)', label: 'Medium' },
                            { color: 'rgb(255,200,0)', label: 'Cool (High Value)' }
                        ];
                    
                    case 'ocean':
                        return [
                            { color: 'rgb(0,50,150)', label: 'Deep (Low Value)' },
                            { color: 'rgb(0,100,200)', label: 'Medium' },
                            { color: 'rgb(0,150,255)', label: 'Shallow (High Value)' }
                        ];
                    
                    case 'rainbow':
                        return [
                            { color: 'rgb(255,0,0)', label: 'Red (0.0)' },
                            { color: 'rgb(255,255,0)', label: 'Yellow (0.2)' },
                            { color: 'rgb(0,255,0)', label: 'Green (0.4)' },
                            { color: 'rgb(0,255,255)', label: 'Cyan (0.6)' },
                            { color: 'rgb(0,0,255)', label: 'Blue (0.8)' },
                            { color: 'rgb(255,0,255)', label: 'Magenta (1.0)' }
                        ];
                    
                    case 'grayscale':
                    case 'raw':
                    default:
                        return [
                            { color: 'rgb(0,0,0)', label: 'Low (0.0)' },
                            { color: 'rgb(128,128,128)', label: 'Medium (0.5)' },
                            { color: 'rgb(255,255,255)', label: 'High (1.0)' }
                        ];
                }
            }
            
            updateLegend() {
                const legend = document.getElementById('legend');
                const mode = this.controls.colorMode.value;
                const items = this.getLegendItems(mode);
                
                legend.innerHTML = '';
                
                items.forEach(item => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const colorSample = document.createElement('div');
                    colorSample.className = 'color-sample';
                    colorSample.style.backgroundColor = item.color;
                    
                    const label = document.createElement('span');
                    label.textContent = item.label;
                    
                    legendItem.appendChild(colorSample);
                    legendItem.appendChild(label);
                    legend.appendChild(legendItem);
                });
            }
            
            renderNoise() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const scale = Number(this.controls.scale.value);
                const octaves = Number(this.controls.octaves.value);
                const persistence = Number(this.controls.persistence.value) / 100;
                const zOffset = Number(this.controls.zOffset.value) / 50;
                const resolution = Number(this.controls.resolution.value);
                const showGrid = this.controls.showGrid.checked;
                const showContours = this.controls.showContours.checked;
                const show3D = this.controls.show3D.checked;
                const showLabels = this.controls.showLabels.checked;
                const colorMode = this.controls.colorMode.value;
                
                this.ctx.clearRect(0, 0, width, height);
                
                this.noiseData = this.perlin.getRawData(width, height, scale, octaves, persistence, zOffset, resolution);
                
                if (this.controls.dataType.value === 'octave') {
                    this.octaveData = this.perlin.getOctaveData(width, height, scale, octaves, persistence, zOffset, resolution);
                }
                
                this.statsData = this.perlin.getStatsData(this.noiseData);
                
                const cellWidth = resolution;
                const cellHeight = resolution;
                
                for (let y = 0; y < this.noiseData.length; y++) {
                    for (let x = 0; x < this.noiseData[y].length; x++) {
                        const value = this.noiseData[y][x];
                        const color = this.getColorForValue(value, colorMode);
                        
                        this.ctx.fillStyle = color;
                        
                        if (show3D) {
                            const heightOffset = value * 5 * resolution;
                            this.ctx.fillRect(
                                x * cellWidth, 
                                y * cellHeight - heightOffset, 
                                cellWidth, 
                                cellHeight + heightOffset
                            );
                            
                            const shadowAlpha = 0.2;
                            this.ctx.fillStyle = value > 0.5 ? 
                                `rgba(255,255,255,${shadowAlpha})` : 
                                `rgba(0,0,0,${shadowAlpha})`;
                            this.ctx.fillRect(
                                x * cellWidth, 
                                y * cellHeight - heightOffset, 
                                cellWidth, 
                                cellHeight / 4
                            );
                        } else {
                            this.ctx.fillRect(
                                x * cellWidth, 
                                y * cellHeight, 
                                cellWidth, 
                                cellHeight
                            );
                        }
                    }
                }
                
                if (showGrid) {
                    this.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    this.ctx.lineWidth = 0.5;
                    
                    for (let y = 0; y <= height; y += cellHeight) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(width, y);
                        this.ctx.stroke();
                    }
                    
                    for (let x = 0; x <= width; x += cellWidth) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, height);
                        this.ctx.stroke();
                    }
                }
                
                if (showContours) {
                    const contourLevels = 10;
                    const contourThreshold = 1 / contourLevels;
                    
                    this.ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.lineWidth = 1;
                    
                    for (let y = 0; y < this.noiseData.length - 1; y++) {
                        for (let x = 0; x < this.noiseData[y].length - 1; x++) {
                            const val = this.noiseData[y][x];
                            const valRight = this.noiseData[y][x + 1];
                            const valBottom = this.noiseData[y + 1][x];
                            
                            for (let i = 1; i < contourLevels; i++) {
                                const threshold = i * contourThreshold;
                                if ((val < threshold && valRight >= threshold) || 
                                    (val >= threshold && valRight < threshold)) {
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(
                                        x * cellWidth + cellWidth, 
                                        y * cellHeight
                                    );
                                    this.ctx.lineTo(
                                        x * cellWidth + cellWidth, 
                                        (y + 1) * cellHeight
                                    );
                                    this.ctx.stroke();
                                }
                                
                                if ((val < threshold && valBottom >= threshold) || 
                                    (val >= threshold && valBottom < threshold)) {
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(
                                        x * cellWidth, 
                                        y * cellHeight + cellHeight
                                    );
                                    this.ctx.lineTo(
                                        (x + 1) * cellWidth, 
                                        y * cellHeight + cellHeight
                                    );
                                    this.ctx.stroke();
                                }
                            }
                        }
                    }
                }
                
                if (showLabels && resolution >= 5) {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.font = `${Math.min(10, resolution - 2)}px monospace`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    for (let y = 0; y < this.noiseData.length; y++) {
                        for (let x = 0; x < this.noiseData[y].length; x++) {
                            const value = this.noiseData[y][x];
                            const displayValue = value.toFixed(2);
                            
                            const brightness = value > 0.5 ? 0 : 255;
                            this.ctx.fillStyle = `rgb(${brightness},${brightness},${brightness})`;
                            
                            this.ctx.fillText(
                                displayValue,
                                x * cellWidth + cellWidth / 2,
                                y * cellHeight + cellHeight / 2
                            );
                        }
                    }
                }
            }
            
            handleCanvasHover(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const resolution = Number(this.controls.resolution.value);
                const cellX = Math.floor(x / resolution);
                const cellY = Math.floor(y / resolution);
                
                if (cellY < this.noiseData.length && cellX < this.noiseData[cellY].length) {
                    const value = this.noiseData[cellY][cellX];
                    this.hoveredCell = { x: cellX, y: cellY, value };
                    
                    this.hoverInfo.textContent = `Position: (${cellX}, ${cellY}) | Value: ${value.toFixed(4)}`;
                }
            }
            
            updateDataDisplay() {
                const dataType = this.controls.dataType.value;
                const sampleSize = this.controls.dataSampleSize.value;
                
                this.dataDisplay.style.display = 'block';
                
                let content = '';
                
                switch (dataType) {
                    case 'raw':
                        content = this.formatRawData(sampleSize);
                        break;
                    case 'octave':
                        content = this.formatOctaveData(sampleSize);
                        break;
                    case 'gradient':
                        content = this.formatGradientData();
                        break;
                    case 'stats':
                        content = this.formatStatsData();
                        break;
                }
                
                this.dataDisplay.innerHTML = content;
            }
            
            formatRawData(sampleSize) {
                let maxRows, maxCols;
                
                switch (sampleSize) {
                    case 'small':
                        maxRows = maxCols = 10;
                        break;
                    case 'medium':
                        maxRows = maxCols = 20;
                        break;
                    case 'large':
                    default:
                        maxRows = this.noiseData.length;
                        maxCols = this.noiseData[0].length;
                }
                
                let content = '<h3>Raw Noise Values</h3>';
                content += '<table style="font-size: 12px; border-collapse: collapse;">';
                
                content += '<tr><th style="border: 1px solid #ddd; padding: 3px;">y\\x</th>';
                for (let x = 0; x < Math.min(maxCols, this.noiseData[0].length); x++) {
                    content += `<th style="border: 1px solid #ddd; padding: 3px;">${x}</th>`;
                }
                content += '</tr>';
            
                for (let y = 0; y < Math.min(maxRows, this.noiseData.length); y++) {
                    content += `<tr><th style="border: 1px solid #ddd; padding: 3px;">${y}</th>`;
                    
                    for (let x = 0; x < Math.min(maxCols, this.noiseData[y].length); x++) {
                        const value = this.noiseData[y][x];
                        const backgroundColor = this.getColorForValue(value, 'grayscale');
                        const textColor = value > 0.5 ? 'black' : 'white';
                        
                        content += `<td style="border: 1px solid #ddd; padding: 3px; background-color: ${backgroundColor}; color: ${textColor};">
                            ${value.toFixed(3)}
                        </td>`;
                    }
                    
                    content += '</tr>';
                }
                
                content += '</table>';
                
                if (this.noiseData.length > maxRows || this.noiseData[0].length > maxCols) {
                    content += '<p><em>Table truncated. Select "Large" sample size to see full data.</em></p>';
                }
                
                return content;
            }
            
            formatOctaveData(sampleSize) {
                if (!this.octaveData) {
                    const scale = Number(this.controls.scale.value);
                    const octaves = Number(this.controls.octaves.value);
                    const persistence = Number(this.controls.persistence.value) / 100;
                    const zOffset = Number(this.controls.zOffset.value) / 50;
                    const resolution = Number(this.controls.resolution.value);
                    
                    this.octaveData = this.perlin.getOctaveData(
                        this.canvas.width, 
                        this.canvas.height, 
                        scale, 
                        octaves, 
                        persistence, 
                        zOffset, 
                        resolution
                    );
                }
                
                let maxRows, maxCols;
                
                switch (sampleSize) {
                    case 'small':
                        maxRows = maxCols = 5;
                        break;
                    case 'medium':
                        maxRows = maxCols = 10;
                        break;
                    case 'large':
                    default:
                        maxRows = maxCols = 20;
                }
                
                let content = '<h3>Individual Octave Values</h3>';
                
                this.octaveData.forEach((octave, index) => {
                    content += `<h4>Octave ${index} (Frequency: ${octave.frequency.toFixed(2)}, Amplitude: ${octave.amplitude.toFixed(3)})</h4>`;
                    content += '<table style="font-size: 12px; border-collapse: collapse; margin-bottom: 20px;">';
                    
                    content += '<tr><th style="border: 1px solid #ddd; padding: 3px;">y\\x</th>';
                    for (let x = 0; x < Math.min(maxCols, octave.data[0].length); x++) {
                        content += `<th style="border: 1px solid #ddd; padding: 3px;">${x}</th>`;
                    }
                    content += '</tr>';
                    
                    for (let y = 0; y < Math.min(maxRows, octave.data.length); y++) {
                        content += `<tr><th style="border: 1px solid #ddd; padding: 3px;">${y}</th>`;
                        
                        for (let x = 0; x < Math.min(maxCols, octave.data[y].length); x++) {
                            const value = octave.data[y][x];
                            const normalizedValue = value / octave.amplitude;
                            const backgroundColor = this.getColorForValue(normalizedValue, 'grayscale');
                            const textColor = normalizedValue > 0.5 ? 'black' : 'white';
                            
                            content += `<td style="border: 1px solid #ddd; padding: 3px; background-color: ${backgroundColor}; color: ${textColor};">
                                ${value.toFixed(3)}
                            </td>`;
                        }
                        
                        content += '</tr>';
                    }
                    
                    content += '</table>';
                });
                
                return content;
            }
            
            formatGradientData() {
                const sampleX = Math.floor(this.canvas.width / 2);
                const sampleY = Math.floor(this.canvas.height / 2);
                const scale = Number(this.controls.scale.value);
                const zOffset = Number(this.controls.zOffset.value) / 50;
                
                this.perlin.noise(sampleX / scale, sampleY / scale, zOffset);
                
                let content = '<h3>Gradient Vectors at Sample Point</h3>';
                content += `<p>Sample Point: (${sampleX}, ${sampleY})</p>`;
                
                content += '<table style="border-collapse: collapse; margin-bottom: 20px;">';
                content += '<tr><th style="border: 1px solid #ddd; padding: 8px;">Corner</th><th style="border: 1px solid #ddd; padding: 8px;">Gradient Value</th></tr>';
                
                for (const [key, value] of Object.entries(this.perlin.lastGradients)) {
                    content += `<tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">${key}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">${value.toFixed(4)}</td>
                    </tr>`;
                }
                
                content += '</table>';
                
                return content;
            }
            
            formatStatsData() {
                if (!this.statsData) {
                    this.statsData = this.perlin.getStatsData(this.noiseData);
                }
                
                let content = '<h3>Statistical Analysis</h3>';
                
                content += '<h4>Basic Statistics</h4>';
                content += '<table style="border-collapse: collapse; margin-bottom: 20px;">';
                content += '<tr><th style="border: 1px solid #ddd; padding: 8px;">Statistic</th><th style="border: 1px solid #ddd; padding: 8px;">Value</th></tr>';
                
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">Minimum</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.min.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">Maximum</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.max.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">Mean</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.mean.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">Median</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.median.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">Standard Deviation</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.stdDev.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">10th Percentile</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.p10.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">25th Percentile</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.p25.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">75th Percentile</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.p75.toFixed(4)}</td></tr>`;
                content += `<tr><td style="border: 1px solid #ddd; padding: 8px;">90th Percentile</td><td style="border: 1px solid #ddd; padding: 8px;">${this.statsData.p90.toFixed(4)}</td></tr>`;
                
                content += '</table>';
                
                content += '<h4>Histogram</h4>';
                content += '<table style="border-collapse: collapse; margin-bottom: 20px;">';
                content += '<tr><th style="border: 1px solid #ddd; padding: 8px;">Bin Range</th><th style="border: 1px solid #ddd; padding: 8px;">Count</th><th style="border: 1px solid #ddd; padding: 8px;">Frequency</th><th style="border: 1px solid #ddd; padding: 8px;">Visualization</th></tr>';
                
                const maxFrequency = Math.max(...this.statsData.histogram.map(bin => bin.frequency));
                
                this.statsData.histogram.forEach(bin => {
                    const barWidth = (bin.frequency / maxFrequency) * 100;
                    
                    content += `<tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">${bin.binStart.toFixed(2)} - ${bin.binEnd.toFixed(2)}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">${bin.count}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">${(bin.frequency * 100).toFixed(2)}%</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            <div style="background-color: #4CAF50; width: ${barWidth}%; height: 20px;"></div>
                        </td>
                    </tr>`;
                });
                
                content += '</table>';
                
                return content;
            }
            
            exportData() {
                const dataType = this.controls.dataType.value;
                let csvContent = '';
                let filename = '';
                
                switch (dataType) {
                    case 'raw':
                        csvContent = this.createRawDataCSV();
                        filename = 'noise_raw_data.csv';
                        break;
                    case 'octave':
                        csvContent = this.createOctaveDataCSV();
                        filename = 'noise_octave_data.csv';
                        break;
                    case 'gradient':
                        csvContent = this.createGradientDataCSV();
                        filename = 'noise_gradient_data.csv';
                        break;
                    case 'stats':
                        csvContent = this.createStatsDataCSV();
                        filename = 'noise_stats_data.csv';
                        break;
                }
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            createRawDataCSV() {
                let csvContent = 'y,x,value\n';
                
                for (let y = 0; y < this.noiseData.length; y++) {
                    for (let x = 0; x < this.noiseData[y].length; x++) {
                        csvContent += `${y},${x},${this.noiseData[y][x]}\n`;
                    }
                }
                
                return csvContent;
            }
            
            createOctaveDataCSV() {
                if (!this.octaveData) {
                    const scale = Number(this.controls.scale.value);
                    const octaves = Number(this.controls.octaves.value);
                    const persistence = Number(this.controls.persistence.value) / 100;
                    const zOffset = Number(this.controls.zOffset.value) / 50;
                    const resolution = Number(this.controls.resolution.value);
                    
                    this.octaveData = this.perlin.getOctaveData(
                        this.canvas.width, 
                        this.canvas.height, 
                        scale, 
                        octaves, 
                        persistence, 
                        zOffset, 
                        resolution
                    );
                }
                
                let csvContent = 'octave,frequency,amplitude,y,x,value\n';
                
                this.octaveData.forEach(octave => {
                    for (let y = 0; y < octave.data.length; y++) {
                        for (let x = 0; x < octave.data[y].length; x++) {
                            csvContent += `${octave.octave},${octave.frequency},${octave.amplitude},${y},${x},${octave.data[y][x]}\n`;
                        }
                    }
                });
                
                return csvContent;
            }
            
            createGradientDataCSV() {
                const sampleX = Math.floor(this.canvas.width / 2);
                const sampleY = Math.floor(this.canvas.height / 2);
                const scale = Number(this.controls.scale.value);
                const zOffset = Number(this.controls.zOffset.value) / 50;
                
                this.perlin.noise(sampleX / scale, sampleY / scale, zOffset);
                
                let csvContent = 'corner,gradient_value\n';
                
                for (const [key, value] of Object.entries(this.perlin.lastGradients)) {
                    csvContent += `${key},${value}\n`;
                }
                
                return csvContent;
            }
            
            createStatsDataCSV() {
                if (!this.statsData) {
                    this.statsData = this.perlin.getStatsData(this.noiseData);
                }
                
                let csvContent = 'statistic,value\n';
                csvContent += `min,${this.statsData.min}\n`;
                csvContent += `max,${this.statsData.max}\n`;
                csvContent += `mean,${this.statsData.mean}\n`;
                csvContent += `median,${this.statsData.median}\n`;
                csvContent += `standard_deviation,${this.statsData.stdDev}\n`;
                csvContent += `p10,${this.statsData.p10}\n`;
                csvContent += `p25,${this.statsData.p25}\n`;
                csvContent += `p75,${this.statsData.p75}\n`;
                csvContent += `p90,${this.statsData.p90}\n\n`;
                
                csvContent += 'bin_start,bin_end,count,frequency\n';
                this.statsData.histogram.forEach(bin => {
                    csvContent += `${bin.binStart},${bin.binEnd},${bin.count},${bin.frequency}\n`;
                });
                
                return csvContent;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const visualizer = new NoiseVisualizer();
        });
    </script>
</body>
</html>